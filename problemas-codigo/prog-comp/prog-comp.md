# Programación Competitiva 

## N1: Fundamentos

Sintaxis básica (input/output, bucles, condiciones)

Tipos de datos y estructuras básicas

Complejidad algorítmica: notación Big-O

Aritmética modular, potencias rápidas


### Ej

1. Suma de dos números (Two Sum)

2. Máximo de una lista

3. Invertir una cadena

4. Palíndromo

5. Contar caracteres o palabras

6. Búsqueda lineal

7. Rotar una matriz

8. Eliminar duplicados de un array

9. Encontrar el segundo número más grande

10. FizzBuzz

11. Número par o impar

12. Reversa de un número

13. Factorial iterativo

13. Encontrar elementos comunes en dos listas

14. Suma de dígitos
 

## N2: Estructuras de Datos Clásicas

Arrays, strings, sets, maps

Pilas, colas, colas de prioridad

Recursión y backtracking básico


### Ej:

16. Paréntesis balanceados (Stack)

17. Cola con dos pilas

18. Implementar una pila con array

19. Búsqueda binaria

20. Insertar y eliminar en lista enlazada

21. Detectar duplicados con conjuntos

22. Subarray con suma máxima

23. Intersección de arrays

24. Anagramas

25. Histograma más grande (stack)


## N3: Algoritmos Básicos

Búsqueda binaria

Ordenamientos (quicksort, mergesort)

Two pointers, sliding window

Greedy


### Ej

26. Ordenamiento por selección / inserción / quicksort / mergesort

27. Búsqueda binaria en array rotado

28. Encuentra el primer y último índice de un número

29. Contenedor con más agua (Two Pointers)

30. Problema de los 3Sum

31. Sumar números representados por listas enlazadas

32. Rotación de cadena

33. Subcadena más larga sin caracteres repetidos

34. Encuentra todos los pares con suma dada

35. Combinaciones de paréntesis válidas



## N4: Programación Dinámica

1D: Fibonacci, suma máxima

2D: caminos, mochilas

DP con decisiones binarias o múltiples


### Ej: 

36. Fibonacci con memorización

37. Climbing Stairs

38. Subconjunto con suma dada

39. Mochila 0/1 (0-1 Knapsack)

40. Mínimo número de monedas (Coin Change)

41. Palabra más larga que se puede construir

42. Secuencia común más larga (LCS)

43. Número de formas de sumar n

44. Edit Distance

45. Longest Increasing Subsequence

46. Partition Equal Subset Sum

47. Decode Ways

48. Caminos mínimos en una cuadrícula

49. Jump Game

50. Número de caminos únicos


## N5: Grafos

DFS, BFS, Dijkstra, Bellman-Ford

Union-Find, Kruskal, Prim

Componentes conexas, topológico


### Ej 

51. BFS (recorrido por niveles)

52. DFS (recorrido profundo)

53. Detectar ciclo en grafo dirigido

54. Detectar ciclo en grafo no dirigido

55. Componentes conexos

56. Número de islas

57. Camino más corto con BFS

58. Dijkstra

59. Bellman-Ford

60. Floyd-Warshall

61. Árbol de expansión mínima (Kruskal / Prim)

62. Topological Sort

63. Camino más largo en DAG

64. Curso Schedule

65. Union-Find: conjuntos disjuntos

66. Encuentra puentes y puntos de articulación


## N6: Avanzado

Segment Tree, Fenwick Tree

Técnicas matemáticas: combinatoria, teoría de números

Geometría computacional

DP optimizada, programación con bits


## Ej: 

67. Criba de Eratóstenes

68. MCD y mcm

69. Algoritmo de Euclides extendido

70. Inverso modular

71. Exponenciación rápida

72. Potencia modular

73. Número primo más cercano

74. Conteo de divisores

75. Combinatoria: nCr

76. Propiedades de congruencia

77. Problemas de suma de dígitos

78. Cálculo de números triangulares

79. Cálculo de sumas y restas modulares

80. Conteo de pares coprimos

81. Segment Tree: suma de rango

82. Segment Tree: actualizaciones de rango

83. Fenwick Tree (Binary Indexed Tree)

84. Bitmask DP

85. Trie: búsqueda eficiente de cadenas

86. Suffix Array y LCP

87. DP en árboles (ej. House Robber III)

88. Lowest Common Ancestor

89. Discretización de coordenadas

90. Mo’s Algorithm

91. Heavy Light Decomposition

92. DP con Sliding Window

93. Interval DP

94. Convex Hull (geometría)

95. Sweep Line

96. Problemas NP (ej. viajante)

97. Algoritmos probabilísticos

98. Teorema del resto chino

99. Números catalanes

100. Hashing con doble módulo
