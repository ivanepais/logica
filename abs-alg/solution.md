|| Herramientas

	+ - * / ^ [] log func derv intr

	cons, var, return

	Estructura: 

		bucles, array, tree




|| Soluciones 
	
	Pensar más allá: 

		Problema mundo real -> Buscar soluciones en el mundo de las ideas -> Formulaciones/Metodos

		Mundo de las ideas -> herramientas para el mundo real/Metodos


		Abstracción: 

			Generalización: 

				Caso particular -> Caso general

				Fórmula particular | Fórmula general


		Solución: 

			Inicio/nada -> Final/solución 

				Transformaciones


		Idea-creación: 

			Idea  ->  Creación 

				Código 

			Inicio -> Fin


|| Algoritmos
	
	Lectura: 
	
	encapsular




|| Ing inversa 
	
	Abstracción: 

		Pensar más allá: 

			Cómo se llego a/pensó la solución

		Pensar en cómo se pudo implementar 

		-> Metodo -> reimplementación 


|| UI/UX 
	 
	Display: 

		normal flow: margin, border ,padding, content

		flex: 

		grid: 

		box-alignment: 


	Soporte: 

		Viejo: 

		Moderno: 


	
	Metodos: 



|| Problemas: 

	1. Conceptos claves -> Conceptos relacionados 

		Pueden ser objetos, entidades, operaciones o relaciones relevantes.

		Pueden agruparse en una misma entidad o clase, deben tener características y comportamientos similares.


	2. Usar clases (POO) o estructuras de datos para representar los conceptos identificados. 

		Define atributos y métodos que describan las características y comportamientos de cada clase.


	3. Definir interfaces: 	

		Que especifiquen cómo interactuar con ellas, claramente. 

		Oculta los detalles internos y expón solo los métodos y atributos necesarios para el uso externo.

			Interfaces: 

				Define un conjunto de métodos y/o atributos que especifican cómo interactuar con un objeto o una clase.

				Establece un contrato que debe cumplirse por cualquier clase que la implemente. 

				Define qué métodos deben estar disponibles y cómo deben utilizarse, pero no proporciona su implementación concreta.

				Promueven la abstracción, el encapsulamiento y proporcionan una forma de comunicarse con los objetos sin preocuparse por su implementación interna. 

				Se puede usar clases abstractas o interfaces en sí mismas y luego implementarlas en diferentes clases. 

				Facilita la sustitución de una implementación con otra y promueve la modularidad y la reutilización de código.


	4. Herencia o composición: 

		Cuando sea apropiado, para establecer relaciones entre las clases y reutilizar código. 

		Herencia: 

			Permite crear nuevas clases basadas en una clase existente

		Composición: 

			Combina múltiples clases para formar una nueva clase.


	5. Abstracción lógica en común: 

		Identificar la lógica común entre diferentes clases o métodos y encapsúlala en funciones o clases separadas.

		Promueve la reutilización de código y evita la duplicación.


	6. Revisa y mejora la abstracción: 	

		Las clases y estructuras de datos deben representar de manera precisa y eficiente los conceptos y relaciones del problema.


	7. Pruebas: 

		Verificar que tu abstracción funcione correctamente y resuelva el problema de manera esperada.

		Realiza ajustes y mejoras según sea necesario.


	8. Modularidad: 

		Componentes pequeños y bien definidos puedan ser entendidos y modificados de forma independiente, facilitando el mantenimiento. 

			Código modular: 

				Dividir un programa en módulos más pequeños y bien definidos que realizan tareas específicas. 

				Cada módulo tiene una responsabilidad clara y se puede desarrollar, probar y mantener de forma independiente.

				Los módulos se pueden componer para construir el programa completo.

				Cada módulo se centra en una tarea o funcionalidad específica, lo que facilita la lectura, el mantenimiento y la depuración del código.

				Se pueden reutilizar en diferentes proyectos o contextos, lo que ahorra tiempo y esfuerzo

				Se pueden implementar utilizando clases, funciones, paquetes o cualquier otro mecanismo proporcionado por el lenguaje de programación.

				Es importante definir interfaces claras entre los módulos para establecer cómo interactúan y se comunican entre sí. Esto permite que los módulos sean independientes unos de otros y se puedan modificar o reemplazar sin afectar a otros módulos.

	9. Revisa y refactoriza: 

		Cuando las necesidades cambian, Asegúrate que la abstracción siga siendo eficaz y cumpla con los requisitos actuales.


